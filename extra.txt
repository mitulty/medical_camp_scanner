
/*
*
* Function Name: left_turn_wls
* Input: void
* Output: void
* Logic: Uses white line sensors to turn left until black line is encountered
* Example Call: left_turn_wls();
*
*/

// void left_turn_wls(void)
// {
// 	//allign_at_node();
// 	forward();
// 	velocity(200, 200);
// 	_delay_ms(200);
// 	left();
// 	velocity(150, 150);
// 	_delay_ms(700);
// 	while (1)
// 	{
// 		// get the ADC converted data of center white line sensors from their appropriate channel number
// 		center_wl_sensor_data = convert_analog_channel_data(center_wl_sensor_channel);
// 		if (center_wl_sensor_data < THRESHOLD_WLS)
// 		{
// 			left();
// 			velocity(150, 150);
// 		}
// 		else
// 			break;
// 		_delay_ms(5);
// 	}
// 	stop();
// 	if (dir_flag == 'n')
// 		dir_flag = 'w';
// 	else if (dir_flag == 'w')
// 		dir_flag = 's';
// 	else if (dir_flag == 's')
// 		dir_flag = 'e';
// 	else
// 		dir_flag = 'n';
// }

/*
*
* Function Name: right_turn_wls
* Input: void
* Output: void
* Logic: Uses white line sensors to turn right until black line is encountered
* Example Call: right_turn_wls();
*
*/

// void right_turn_wls(void)
// {
// 	//allign_at_node();
// 	forward();
// 	velocity(200, 200);
// 	_delay_ms(200);
// 	right();
// 	velocity(150, 150);
// 	_delay_ms(300);
// 	while (1)
// 	{
// 		// get the ADC converted data of center white line sensors from their appropriate channel number
// 		center_wl_sensor_data = convert_analog_channel_data(center_wl_sensor_channel);
// 		if (center_wl_sensor_data < THRESHOLD_WLS)
// 		{

// 			right();
// 			velocity(160, 170);
// 		}
// 		else
// 			break;
// 		_delay_ms(5);
// 	}
// 	//	printf("\n\texit value %d \n", convert_analog_channel_data(center_wl_sensor_channel));
// 	stop();
// 	velocity(0, 0);
// 	if (dir_flag == 'n')
// 		dir_flag = 'e';
// 	else if (dir_flag == 'e')
// 		dir_flag = 's';
// 	else if (dir_flag == 's')
// 		dir_flag = 'w';
// 	else
// 		dir_flag = 'n';
// }

void allign_at_node()
{
	left_wl_sensor_data = convert_analog_channel_data(left_wl_sensor_channel);
	center_wl_sensor_data = convert_analog_channel_data(center_wl_sensor_channel);
	right_wl_sensor_data = convert_analog_channel_data(right_wl_sensor_channel);
	if (left_wl_sensor_data > THRESHOLD_WLS || center_wl_sensor_data > THRESHOLD_WLS || right_wl_sensor_data > THRESHOLD_WLS)
		return;
	int limit = 50;
	int found = 0;
	while (1)
	{
		left();
		velocity(150, 100);
		for (int i = 0; i < (limit); i++)
		{
			left_wl_sensor_data = convert_analog_channel_data(left_wl_sensor_channel);
			center_wl_sensor_data = convert_analog_channel_data(center_wl_sensor_channel);
			right_wl_sensor_data = convert_analog_channel_data(right_wl_sensor_channel);
			if (left_wl_sensor_data > THRESHOLD_WLS || center_wl_sensor_data > THRESHOLD_WLS || right_wl_sensor_data > THRESHOLD_WLS)
			{
				stop();
				found = 1;
				break;
			}
			_delay_ms(2);
		}
		stop();
		_delay_ms(5);
		right();
		velocity(150, 100);
		for (int i = 0; i < (limit * 1.7); i++)
		{
			left_wl_sensor_data = convert_analog_channel_data(left_wl_sensor_channel);
			center_wl_sensor_data = convert_analog_channel_data(center_wl_sensor_channel);
			right_wl_sensor_data = convert_analog_channel_data(right_wl_sensor_channel);
			if (left_wl_sensor_data > THRESHOLD_WLS || center_wl_sensor_data > THRESHOLD_WLS || right_wl_sensor_data > THRESHOLD_WLS)
			{
				stop();
				found = 1;
				break;
			}
			_delay_ms(2);
		}
		stop();
		_delay_ms(5);
		left();
		velocity(150, 100);
		for (int i = 0; i < limit; i++)
		{
			left_wl_sensor_data = convert_analog_channel_data(left_wl_sensor_channel);
			center_wl_sensor_data = convert_analog_channel_data(center_wl_sensor_channel);
			right_wl_sensor_data = convert_analog_channel_data(right_wl_sensor_channel);
			if (left_wl_sensor_data > THRESHOLD_WLS || center_wl_sensor_data > THRESHOLD_WLS || right_wl_sensor_data > THRESHOLD_WLS)
			{
				stop();
				found = 1;
				break;
			}
			_delay_ms(2);
		}
		stop();
		_delay_ms(1000);
		limit += 50;
		if (found == 1)
			break;
	}
}
