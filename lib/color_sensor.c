/*
This experiment demonstrates the use of Color Sensor.
Concepts covered: External Interrupts
Micro-controller pins used:
PORTD0 (INT0): External Interrupt used to count the number of pulses generated by the color sensor
PORTD4 & PORTD5: Control the S0 and S1 pins of the color sensor to choose a scaling factor
PORTD6 & PORTD7: Control S2 and S3 pins of the color sensor to choose the color filter.   
Note:
1. Make sure that in the configuration options following settings are
done for proper operation of the code
Micro-controller: atmega2560
Frequency: 14745600
Optimization: -O0  (For more information read section: Selecting proper optimization
options below figure 2.22 in the Software Manual)
2.	It is observed that external interrupts does not work with the optimization level -Os
Connections:
 
 *Vcc is connected on servo pod pin 7
 *Vdd is connected on servo pod pin 6
 *Output of the sensor is connected to PD0 (INT0) of Atmega 2560 i.e Pin 20 on expansion slot
 *S0 of the sensor is connected to PD4 of Atmega 2560 i.e Pin 25 on expansion slot
 *S1 of the sensor is connected to PD5 of Atmega 2560 i.e Pin 29 on expansion slot
 *S2 of the sensor is connected to PD6 of Atmega 2560 i.e Pin 33 on expansion slot
 *S3 of the sensor is connected to PD7 of Atmega 2560 i.e Pin 34 on expansion slot
 */

#include "firebird_avr.h" // Header file included that contains macro definitions essential for Firebird V robot
#include <util/delay.h>	  // Standard AVR Delay Library
#include <math.h>		  //included to support power function
#include "color_sensor.h"
#define COLOR_THRESHOLD 1100
volatile unsigned long int pulse = 0; //to keep the track of the number of pulses generated by the color sensor
volatile unsigned long int red;		  // variable to store the pulse count when read_red function is called
volatile unsigned long int blue;	  // variable to store the pulse count when read_blue function is called
volatile unsigned long int green;	  // variable to store the pulse count when read_green function is called

void color_sensor_pin_config(void)
{
	DDRD = DDRD | 0xFE;	  //set PD0 as input for color sensor output
	PORTD = PORTD | 0x01; //Enable internal pull-up for PORTD 0 pin
}

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli();				  //Clears the global interrupt
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
	sei();				  // Enables the global interrupt
}

//ISR for color sensor
ISR(INT0_vect)
{
	pulse++; //increment on receiving pulse from the color sensor
}

void init_devices(void)
{
	cli();					   //Clears the global interrupt
	color_sensor_pin_config(); //color sensor pin configuration
	color_sensor_pin_interrupt_init();
	sei(); // Enables the global interrupt
}

//Filter Selection
void filter_red(void) //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
	PORTD = PORTD & 0x7F; //set S3 low
}

void filter_green(void) //Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
	PORTD = PORTD | 0x80; //set S3 High
}

void filter_blue(void) //Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
	PORTD = PORTD | 0x80; //set S3 High
}

void filter_clear(void) //select no filter
{
	//Filter Select - no filter
	PORTD = PORTD | 0x40; //set S2 High
	PORTD = PORTD & 0x7F; //set S3 Low
}

//Color Sensing Scaling
void color_sensor_scaling() //This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
}

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	red = 0;
	for (int i = 0; i < 5; i++)
	{
		filter_red();	//select red filter
		pulse = 0;		//reset the count to 0
		_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
		red += pulse;	//store the count in variable called red
	}
	red = red / 5;
}

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	green = 0;
	for (int i = 0; i < 5; i++)
	{
		filter_green(); //select green filter
		pulse = 0;		//reset the count to 0
		_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
		green += pulse; //store the count in variable called green
	}
	green = green / 5;
}

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	blue = 0;
	for (int i = 0; i < 5; i++)
	{
		filter_blue();	//select blue filter
		pulse = 0;		//reset the count to 0
		_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
		blue += pulse;	//store the count in variable called blue
	}
	blue = blue / 5;
}

int color_type(void)
{
	red_read();
	_delay_ms(200);
	green_read();
	_delay_ms(200);
	blue_read();
	if (red > COLOR_THRESHOLD && blue < COLOR_THRESHOLD && green < COLOR_THRESHOLD) // Red
		return 5;
	if (red > COLOR_THRESHOLD && blue > COLOR_THRESHOLD && green > COLOR_THRESHOLD)// White
		return 3;
	// if (red < 1000 && blue < 1000 && green > 1000) // Green
	// 	return 3;
	return 4; // Green Color
}
/*
* Sample Main Code
int main(void)
{
    init_devices();
	color_sensor_scaling();
	
	while(1)
    {
       red_read(); //display the pulse count when red filter is selected
	   _delay_ms(500);
	   green_read(); //display the pulse count when green filter is selected
	   _delay_ms(500);
	   blue_read(); //display the pulse count when blue filter is selected
	   _delay_ms(500); 
    }
}
*/